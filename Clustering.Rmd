---
title: "Clustering"
---

# Load required packages

```{r}
library(tidyverse)
library(cluster)
library(factoextra)
```

# Load a data set

- Load `college_scorecard.csv`
- Examine the loaded data set
  - Column names
  - Column types

```{r}
college_data <- read_csv("college_scorecard.csv")
glimpse(college_data)
```
```{r}
head(college_data)
```
```{r}

# Display column names
colnames(college_data)

```
```{r}
# Display column types
sapply(college_data, class)
```
# Select numerical variables for clustering (1 point) 

Select the following numerical variables for clustering analysis:

- cost: Average annual total cost of attendance
- admrate: Admission rate (0 - 100%)
- satavg: Average SAT scores
- avgfacsal: Average faculty salary
- pctpell: Percentage of undergraduate who receive a Pell Grant
- comprate: Rate of first-time, full-time students at four-year institutions who complete their degree within six years
- firstgen: Share of first-generation students
- debt: Median debt of students after leaving school

After selecting these variables, examine them to make sure you have them all correctly.

```{r}
selected_vars <- college_data %>%
  select(cost, admrate, satavg, avgfacsal, pctpell, 
         comprate, firstgen, debt)

# Examine ranges of numerical variables
summary(selected_vars)
```
```{r}
# Standardize the numeric columns in selected_vars
selected_vars_standardized <- selected_vars %>%
  mutate(across(everything(), scale))

# View the standardized data
head(selected_vars_standardized)
```

```{r}
head(selected_vars)
```
```{r}
# Function to summarize college data variables
summarize_college_vars <- function(data) {
  # Select the required variables
  selected_vars <- data %>%
    select(cost, admrate, satavg, avgfacsal, pctpell, 
           comprate, firstgen, debt)
  
  # Calculate summary statistics for each variable
  summary_stats <- selected_vars %>%
    summarize(
      # Cost statistics
      cost_mean = mean(cost, na.rm = TRUE),
      cost_sd = sd(cost, na.rm = TRUE),
      cost_min = min(cost, na.rm = TRUE),
      cost_max = max(cost, na.rm = TRUE),
      
      # Admission rate statistics
      admrate_mean = mean(admrate, na.rm = TRUE),
      admrate_sd = sd(admrate, na.rm = TRUE),
      admrate_min = min(admrate, na.rm = TRUE),
      admrate_max = max(admrate, na.rm = TRUE),
      
      # SAT average statistics
      satavg_mean = mean(satavg, na.rm = TRUE),
      satavg_sd = sd(satavg, na.rm = TRUE),
      satavg_min = min(satavg, na.rm = TRUE),
      satavg_max = max(satavg, na.rm = TRUE),
      
      # Faculty salary statistics
      avgfacsal_mean = mean(avgfacsal, na.rm = TRUE),
      avgfacsal_sd = sd(avgfacsal, na.rm = TRUE),
      avgfacsal_min = min(avgfacsal, na.rm = TRUE),
      avgfacsal_max = max(avgfacsal, na.rm = TRUE),
      
      # Pell grant percentage statistics
      pctpell_mean = mean(pctpell, na.rm = TRUE),
      pctpell_sd = sd(pctpell, na.rm = TRUE),
      pctpell_min = min(pctpell, na.rm = TRUE),
      pctpell_max = max(pctpell, na.rm = TRUE),
      
      # Completion rate statistics
      comprate_mean = mean(comprate, na.rm = TRUE),
      comprate_sd = sd(comprate, na.rm = TRUE),
      comprate_min = min(comprate, na.rm = TRUE),
      comprate_max = max(comprate, na.rm = TRUE),
      
      # First generation student statistics
      firstgen_mean = mean(firstgen, na.rm = TRUE),
      firstgen_sd = sd(firstgen, na.rm = TRUE),
      firstgen_min = min(firstgen, na.rm = TRUE),
      firstgen_max = max(firstgen, na.rm = TRUE),
      
      # Debt statistics
      debt_mean = mean(debt, na.rm = TRUE),
      debt_sd = sd(debt, na.rm = TRUE),
      debt_min = min(debt, na.rm = TRUE),
      debt_max = max(debt, na.rm = TRUE)
    )
  
  return(summary_stats)
}

```

```{r}
summary_results <- summarize_college_vars(college_data)
 print(summary_results)
```

```{r}

# Now create a new variable with a sample of 4 rows using slice_sample
sampled_vars <- selected_vars %>%
  slice_sample(n = 4)

# View the result
head(sampled_vars)
```
```{r}
# Compute distance matrix using dist()
# By default, dist() uses Euclidean distance method
dist_matrix <- dist(sampled_vars)

# View the distance matrix
print(dist_matrix)
```
```{r}
# Extract values from the first two rows for all columns
row1 <- selected_vars_standardized[1, ]
row2 <- selected_vars_standardized[2, ]

# Compute the Euclidean distance manually for all columns
distance <- sqrt(sum((row1 - row2)^2))

# Print the result
print(distance)

```
# Scale variables

## Examine ranges of numerical variables to be used in the clustering analysis (1 point)

- Describe what you found from the compared ranges

The variables have vastly different scales - cost ranges from $7,715 to $62,594, while pctpell (percentage of Pell Grant recipients) ranges from 0.0616 to 0.9451 (or 6.16% to 94.51%).

Some variables like admrate (5.69% to 100%) and comprate (0.0484 to 0.9779) use percentage scales, while others like satavg (666 to 1504) and avgfacsal ($13,059 to $185,850) use completely different units of measurement. These different scales justify the need for standardization before clustering.

## Scale variables (1 point)

```{r}
scaled_data <- selected_vars %>%
  mutate(across(everything(), scale))
```

```{r}
# Summarize each column in scaled_data
scaled_data %>%
  summarize(
    # Cost
    mean_cost = mean(cost),
    sd_cost = sd(cost),
    
    # Admission rate
    mean_admrate = mean(admrate),
    sd_admrate = sd(admrate),
    
    # SAT average
    mean_satavg = mean(satavg),
    sd_satavg = sd(satavg),
    
    # Faculty salary
    mean_avgfacsal = mean(avgfacsal),
    sd_avgfacsal = sd(avgfacsal),
    
    # Pell grant percentage
    mean_pctpell = mean(pctpell),
    sd_pctpell = sd(pctpell),
    
    # Completion rate
    mean_comprate = mean(comprate),
    sd_comprate = sd(comprate),
    
    # First generation
    mean_firstgen = mean(firstgen),
    sd_firstgen = sd(firstgen),
    
    # Debt
    mean_debt = mean(debt),
    sd_debt = sd(debt)
  )
```

```{r}
# Scale variables
nrow(selected_vars)
```
## Examine ranges of the scaled numerical variables (1 point)

```{r}
# Examine ranges of numerical variables
summary(selected_vars)
```

# Find an optimal number of clusters

## Elbow method (1 point)

- Report the number of clusters suggested by the Elbow method
- Justify your decision
- Make sure to ensure reproducibility

```{r}
# Elbow Method
set.seed(123)  # for reproducibility
wss <- function(k) {
  kmeans(scaled_data, k, nstart = 25)$tot.withinss
}
k_values <- 1:10
wss_values <- map_dbl(k_values, wss)

plot(k_values, wss_values,
     type="b", pch = 19,
     xlab="Number of clusters K",
     ylab="Total within-clusters sum of squares")

```

Looking at the elbow plot, I observe that K=4 appears to be the optimal number of clusters. This point represents the "elbow" where increasing K beyond 4 yields diminishing returns in reducing the total within-cluster sum of squares. 

After K=4, the curve starts to level off significantly, suggesting that additional clusters don't provide substantial improvement in explaining the variance in the data.

## Average Silhouette Method (1 point)

- Report the number of clusters suggested by Average Silhouette Method
- Justify your decision
```{r}
# Average Within Cluster of sum of squared
fviz_nbclust(scaled_data, kmeans, method = "wss")
```

```{r}
# Average Silhouette Method
fviz_nbclust(scaled_data, kmeans, method = "silhouette")
```

The optimal number of clusters is 2, as the silhouette width is highest at this point.
At 𝑘= 2 k=2, the silhouette width peaks, suggesting that the data is best partitioned into 2 clusters.
Beyond 2 clusters, the silhouette width decreases, indicating that further splitting may lead to less distinct and less cohesive clustering.


## Gap Statistic Method (1 point)

- Report the number of clusters suggested by Gap Statistic Method
- Justify your decision
- Make sure to ensure reproducibility

```{r}
# Gap Statistic Method
set.seed(123)
gap_stat <- clusGap(scaled_data,FUN = kmeans,nstart = 25,K.max = 10,B = 50)
fviz_gap_stat(gap_stat)

```

Based on the gap statistic plot, the optimal number of clusters appears to be 9, as indicated by the vertical dashed line. This point shows where the gap statistic value starts to level off, showing diminishing returns in adding more clusters. 

The error bars (standard error intervals) also remain relatively stable around this point, suggesting that 9 clusters provides a reliable clustering solution.

## Create an optimal number of clusters based on the elbow method result (1 point)

```{r}
# Create optimal clusters (assuming k=4 from elbow method)
set.seed(123)
final_clusters <- kmeans(scaled_data, centers = 4, nstart = 25)
```

```{r}
final_clusters
```
## Visualize clusters (1 point)

```{r}
# Visualize clusters
fviz_cluster(final_clusters, data = scaled_data,
             palette = "Set2",
             geom = "point",
             ellipse.type = "convex",
             ggtheme = theme_minimal())
```

## Compute mean values of selected variables (cost, admrate, satavg) on each cluster (2 point)

```{r}
# Compute mean values for each cluster
cluster_means <- bind_cols(
  selected_vars,
  cluster = as.factor(final_clusters$cluster)
) %>%
  group_by(cluster) %>%
  summarise(
    avg_cost = mean(cost, na.rm = TRUE),
    avg_admrate = mean(admrate, na.rm = TRUE),
    avg_satavg = mean(satavg, na.rm = TRUE),
    avg_avgfacsal = mean(avgfacsal, na.rm = TRUE),
    avg_pctpell = mean(pctpell, na.rm = TRUE),
    avg_comprate = mean(comprate, na.rm = TRUE),
    avg_firstgen = mean(firstgen, na.rm = TRUE),
    avg_debt = mean(debt, na.rm = TRUE)
  )

```

## Describe how each cluter is similar or different in terms of three variables used in clustering (1 point)

```{r}
# View cluster means
print(cluster_means)
```
Cluster 4 represents elite institutions with the highest average cost ($55,337), lowest admission rates (28.1%), and highest SAT scores (1,362), distinguishing them as highly selective and expensive schools.

Cluster 1 represents mid-tier private institutions with moderately high costs ($40,627), moderate admission rates (66.4%), and above-average SAT scores (1,146), placing them between elite and typical schools.

Clusters 2 and 3 are more accessible, with Cluster 2 having moderate costs ($29,435) and higher admission rates (71.3%) with average SAT scores (1,031), while Cluster 3 has the lowest costs ($23,449), moderate admission rates (62.4%), and lowest SAT scores (951).

```{r}
final_clusters$cluster
```

```{r}
length(final_clusters)
```

```{r}
# Create a dataframe combining the original data with cluster assignments
cluster_data <- data.frame(
  cluster = final_clusters$cluster,
  cost = selected_vars$cost,
  admrate = selected_vars$admrate,
  satavg = selected_vars$satavg,
  avgfacsal = selected_vars$avgfacsal,
  pctpell = selected_vars$pctpell,
  comprate = selected_vars$comprate,
  firstgen = selected_vars$firstgen,
  debt = selected_vars$debt
)
```

```{r}
# Function to perform t-tests between two clusters for all variables
compare_clusters <- function(data, cluster1, cluster2) {
  vars <- c("cost", "admrate", "satavg", "avgfacsal", "pctpell", "comprate", "firstgen", "debt")
  results <- list()
  
  for (var in vars) {
    group1 <- data[data$cluster == cluster1, var]
    group2 <- data[data$cluster == cluster2, var]
    
    test <- t.test(group1, group2)
    
    results[[var]] <- list(
      variable = var,
      t_statistic = test$statistic,
      p_value = test$p.value,
      mean_diff = diff(test$estimate),
      conf_int = test$conf.int
    )
  }
  return(results)
}
```

```{r}
# Perform all pairwise comparisons
pairs <- list(
  c(1,2), c(1,3), c(1,4),
  c(2,3), c(2,4),
  c(3,4)
)
```

```{r}
# Store results
all_comparisons <- list()
for (pair in pairs) {
  comparison_name <- paste("Cluster", pair[1], "vs", pair[2])
  all_comparisons[[comparison_name]] <- compare_clusters(cluster_data, pair[1], pair[2])
}
```

```{r}
# Function to format p-value
format_p <- function(p) {
  if (p < 0.001) return("p < 0.001")
  return(paste("p =", round(p, 3)))
}
```

```{r}
# Print results in a readable format
for (comparison_name in names(all_comparisons)) {
  cat("\n=== ", comparison_name, " ===\n")
  results <- all_comparisons[[comparison_name]]
  
  for (var_name in names(results)) {
    result <- results[[var_name]]
    cat("\n", toupper(var_name), ":\n")
    cat("t =", round(result$t_statistic, 2), "\n")
    cat(format_p(result$p_value), "\n")
    cat("Mean difference:", round(result$mean_diff, 2), "\n")
    cat("95% CI: [", round(result$conf_int[1], 2), ",", round(result$conf_int[2], 2), "]\n")
  }
}
```